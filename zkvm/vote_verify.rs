#![cfg_attr(target_arch = "riscv32", no_std, no_main)]

use nexus_rt::{write_log, read_public_input, read_private_input, write_public_output, hash};

#[nexus_rt::main]
fn main() {
    // Public inputs (visible on-chain)
    let proposal_id = read_public_input::<u32>();
    let merkle_root = read_public_input::<[u8; 32]>();
    
    // Private inputs (only known to the voter)
    let voter_secret = read_private_input::<[u8; 32]>();  // Random secret generated by voter
    let voter_leaf = read_private_input::<[u8; 32]>();    // Voter's leaf in merkle tree
    let merkle_path = read_private_input::<Vec<[u8; 32]>>(); // Merkle proof
    let merkle_indices = read_private_input::<Vec<bool>>(); // Left/right indices for merkle proof
    let choice = read_private_input::<u8>();               // Vote choice (0 or 1)

    // Verify the voter is in the merkle tree
    let mut current = voter_leaf;
    for (i, sibling) in merkle_path.iter().enumerate() {
        let (left, right) = if merkle_indices[i] {
            (current, *sibling)
        } else {
            (*sibling, current)
        };
        current = hash(&[&left[..], &right[..]].concat());
    }

    // Verify merkle root matches
    if current != merkle_root {
        write_log("Error: Invalid merkle proof\n");
        return;
    }

    // Create nullifier (unique per voter-proposal combination)
    let nullifier = hash(&[
        &voter_secret[..],
        &proposal_id.to_le_bytes()[..]
    ].concat());

    // Create vote commitment
    let commitment = hash(&[
        &nullifier[..],
        &[choice][..]
    ].concat());

    // Write public outputs
    write_public_output(&nullifier);    // To prevent double voting
    write_public_output(&commitment);   // To record the vote
    write_public_output(&proposal_id);  // To identify which proposal

    write_log("Anonymous vote verified successfully\n");
} 